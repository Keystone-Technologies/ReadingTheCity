package Android;
use Mojo::Base -base;
use Mojo::JSON 'j';

use Data::Dump 'dump';

has redis => sub { Mojo::Redis2->new };

sub key { join '_', @_ }
sub dekey { split /_/, shift }

sub notification {
  my $self = shift;
  my $json = $self->redis->get('android_notification') or do { warn "No notification\n"; return undef; };
  $json = j($json); # {_id, rssi, major, minor, parent, name, description, url}
  my $id = $json->{major}.$json->{minor};
  warn sprintf("Notification: %s(%s) => %s (%s|%s|%s): %s\n", $id, $json->{rssi}, $json->{name}, $json->{child}, $json->{_id}, $json->{parent}, ($json->{child}?'':$json->{url}->[0]));
  {id => $id, details => $json};
}

sub notify {
  my ($self, $json) = (shift, shift);
  return unless ref $json;
  $self->redis->set(android_notification => j($json));
  return int(rand(10)) == 1 ? 0 : 1;  # Randomly fail on posting to notification bar
}

sub estimotes {
  my $self = shift;
  map { @_ = dekey($_); {major => shift, minor => shift, rssi => $self->redis->hget(beacons => $_)} } @{$self->redis->hkeys('beacons')};
}

sub reset {
  my $self = shift;
  $self->redis->del('notification');
  warn dump($_) foreach $self->estimotes;
}

sub _rssi { shift->redis->hset(beacons => key(shift, shift) => shift) }

####################################################################
package RTC;
use Mojo::Base -base;
use Mojo::JSON 'j';
use Mojo::Redis2;
use Mojo::Log;
use Mojo::UserAgent;

use DBI;
use Data::Dump;

has log => sub { Mojo::Log->new };
has ua => sub { Mojo::UserAgent->new };
has couchdb => 'http://db.xlxcd1.kit.cm:5984';
has db => sub { DBI->connect("dbi:SQLite:dbname=sql.db","","",{AutoCommit=>1}) };
has redis => sub { Mojo::Redis2->new };

has [qw/major minor rssi/];

sub mm { map { $_[0]->$_ } qw/major minor/ }
sub mmr { $_[0]->mm, $_[0]->rssi }
sub dump { Data::Dump::dump({major => $_[0]->major, minor => $_[0]->minor, rssi => $_[0]->rssi}) }
sub dumplog { $_[0]->log->debug($_[0]->dump); $_[0] }

sub reset {
  my $self = shift;
  $self->do("delete from details");
  $self->do("delete from beacons");
  $self->redis->del('notification');
  $self->redis->del('beacons');
}

sub create_tables {
  my $self = shift;
  $self->do("CREATE TABLE IF NOT EXISTS beacons (major integer, minor integer, fetching integer, age integer, parent text);");
  $self->do("CREATE TABLE IF NOT EXISTS details (uuid text, fetching integer, age integer, parent text, json text, show integer);");
}

sub response {
  my ($self, $uuid, $show) = @_;
  $self->do("update details set age=strftime('%s', 'now'),show=? where uuid = ?", undef, $show, $uuid);
  $self->redis->del('notification');
}

sub do { shift->db->do(@_) }
sub selectrow_array {
  my $self = shift;
  my ($statement, $attr, @bind_values) = @_;
  my $sth = $self->db->prepare($statement, $attr||{}) or return undef;
  $sth->execute(@bind_values) or return undef;
  my @row = $sth->fetchrow_array;
  my $rows = $sth->rows;
  $sth->finish;
  $rows, @row;
}

sub details {
  my ($self, $me, $child) = @_;
  if ( $me ) {
    my ($rows, $_child, $fetching, $age, $parent, $json, $show, $pjson, $pshow) = $self->selectrow_array("select d0.uuid as cuuid,d1.fetching as fetching,d1.age as age,d1.parent as parent,d1.json as json,d1.show as show,d2.json as pjson,d2.show as pshow from details d1 left join details d2 on d1.parent=d2.uuid left join details d0 on d0.parent=d1.uuid where d1.uuid = ? limit 1", undef, $me);
    $self->do('insert into details (uuid) values (?)', undef, $me) unless $rows;
    return if (defined $show && !$show) || (defined $pshow && !$pshow);
    #return $self->update($parent, $me) unless defined $show || defined $pshow;
    return if defined $fetching && time() - $fetching < 7;
    if ( (defined $parent && not defined $pjson) || (not defined $age) || time() - $age > 86400 ) {
      $self->do("update details set fetching = strftime('%s', 'now') where uuid = ?", undef, $me);
      $self->ua->get(sprintf('%s/rtc/_design/lookup/_view/details?key="%s"', $self->couchdb, $me) => sub {
        my ($ua, $tx) = @_;
        my $json = $tx->res->json->{rows}->[0]->{value};
        $json->{child} = $child;
        $self->do("update details set fetching=null,age=strftime('%s', 'now'),parent=?,json=?,show=null where uuid = ?", undef, $json->{parent}, j($json), $me);
        $self->details($json->{parent}, $me) if defined $parent && (not defined $show || not defined $pshow);
      });
    }
    return j($json) if $json && (!$parent || ($pshow && not defined $show));
  } else {
    my ($rows, $fetching, $age, $parent, $pjson, $pshow) = $self->selectrow_array('select b.fetching as fetching,b.age as age,b.parent as parent,d.json as json,d.show as show from beacons b left join details d on b.parent=d.uuid where major = ? and minor = ? limit 1', undef, $self->mm);
    $self->do('insert into beacons (major, minor) values (?, ?)', undef, $self->mm) unless $rows;
    #return undef if defined $pshow && !$pshow;
    return if defined $fetching && time() - $fetching < 7;
    if ( (defined $parent && not defined $pjson) || (not defined $age) || time() - $age > 86400 ) {
      $self->do("update beacons set fetching = strftime('%s', 'now') where major = ? and minor = ?", undef, $self->mm);
      $self->ua->get(sprintf('%s/rtc/_design/lookup/_view/beacon?key=[%s,%s]', $self->couchdb, $self->mm) => sub {
        my ($ua, $tx) = @_;
        my $json = $tx->res->json->{rows}->[0]->{value};
        $self->do("update beacons set fetching=null,age=strftime('%s', 'now'),parent=? where major = ? and minor = ?", undef, $json->{parent}, $self->mm);
        $self->details($json->{parent}, undef);
      });
    }
  }
}

####################################################################
package main;
use Mojolicious::Lite;
no warnings;

helper android => sub { Android->new };
helper rtc => sub { RTC->new };

get '/' => 'index';

post '/beacon/:beacon/:rssi' => {rssi => undef} => sub {
  my $c = shift;
  if ( ($c->param('beacon') =~ /^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})-(\d+)-(\d+)$/) ) {
    $c->android->_rssi($2, $3, $c->param('rssi'));
    $c->render(text => '');
  } else {
    $c->render(text => '', status => 401);
  }
};

#post '/show/:uuid/:show' => [show => [(0,1,undef)]] => {show => undef} => sub {
post '/response/:uuid/:show' => {show => undef} => sub {
  my $c = shift;
  $c->rtc->response($c->param('uuid') => $c->param('show'));
  $c->render(text => $c->param('uuid') . ' => ' . ($c->param('show')?'Yes':'No'));
};

del '/reset' => sub {
  my $c = shift;
  $c->rtc->reset;
  $c->render(text => 'Reset');
};

websocket '/notification' => sub {
  my $c = shift;
  $c->on(frame => sub {
    my ($tx, $frame) = @_;
    Mojo::IOLoop->recurring(1 => sub {
      $tx->send({json => $c->android->notification->{details}});
    });
  });
};

Mojo::IOLoop->recurring(0.25 => sub {
  my $notification = app->android->notification; # Return JSON of not the beacon, but the details
  my @beacons = sort { $a->rssi <=> $b->rssi } map { RTC->new(%$_) } app->android->estimotes; # Return array of JSON of the details
  if ( defined $notification && grep { $_->id == $notification->{id} } strong_beacons(@beacons) ) {
    #warn "No change\n";
    return
  } else {
    foreach ( @beacons ) {
      $_->dump;
      if ( app->android->notify($_->details) ) { # Notify using the selected JSON details
        warn "Posted!\n";
        last;
      } else {
        #warn "Not Posted!\n";
      }
    }
  }
});

app->android->reset;
app->rtc->create_tables;
app->start;

sub strong_beacons {
  my @beacons = @_;
  my @strong = ();
  foreach ( 0..$#beacons ) {
    if ( $beacons[$_]->rssi <= $beacons[0]->rssi + 5 ) {
      push @strong, $beacons[$_];
    } else {
      last;
    }
  }
  return @strong;
}

__DATA__

@@ notification.html.ep
% if ( $n->{json} ) {
  <a href="<%= $n->{json}->{url}->[0] %>"><%= $n->{json}->{name} %></a>
% }
