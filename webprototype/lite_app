package Android::Notifier;
use Mojo::Base -base;
use Mojo::JSON 'j';
use Mojo::Redis2;

has redis => sub { Mojo::Redis2->new };

has 'id';

sub notification {
  my $self = shift;
  die "No id supplied\n" unless $self->id;
  j($self->redis->get($self->id))||'{}') or {};
}

sub notify {
  my ($self, $obj) = @_;
  die "No id supplied\n" unless $self->id;
  $self->redis->set($self->id => j($obj)) if ref $obj eq 'HASH';
}

sub clear {
  my $self = shift;
  die "No id supplied\n" unless $self->id;
  $self->redis->del($self->id);
}

####################################################################
package RTC::AndroidNotifier;
use Mojo::Base 'Android::Notifier';
use Data::Dump;

has 'details';

sub notification {
  my $self = shift;
warn "Getting notification...\n";
  my $notification = $self->SUPER::notification;
no warnings;
warn sprintf("Notification: %s(%s) => %s (%s|%s|%s): %s\n", join('_', $notification->{major}, $notification->{minor}), $notification->{rssi}, $notification->{details}->{name}, $notification->{details}->{child}, $notification->{details}->{_id}, $notification->{details}->{parent}, ($notification->{details}->{child}?'':$notification->{details}->{url}->[0]));
  $notification;
}

sub notify {
  my $self = shift;
warn "Notifying...\n";
  return unless ref $self->details eq 'RTC::Details';
  #int(rand(10)) or return;  # Randomly fail on posting to notification bar
  my $notify = $self->SUPER::notify({$self->details->beacon->mmr, details => $self->details->json});
warn $notify ? 1 : 0;
  $notify;
}

####################################################################
####################################################################
package Android::EstimoteSDK;
use Mojo::Base -base;
use Mojo::Redis2;

has redis => sub { Mojo::Redis2->new };

has beacons => sub { {} };
sub beacon { shift->beacons->{shift()} }

sub scan {
  my $self = shift;
  my @beacons = @{$self->redis->hkeys('estimote_beacons')};
  foreach my $key ( @beacons ) {
    $self->beacons->{$key} ||= Android::EstimoteSDK::Beacon->new(estimote => $self, _dekey($key));
  }
  foreach my $key ( keys %{$self->beacons} ) {
    delete $self->beacons->{$key} unless grep { $_ eq $key } @beacons;
  }
}

sub _dekey { my ($major, $minor) = split /_/, shift; return major => $major, minor => $minor }

####################################################################
package Android::EstimoteSDK::Beacon;
use Mojo::Base -base;

has 'estimote';

has [qw/major minor/];
sub key { join '_', $_[0]->major, $_[0]->minor }
sub rssi {
  my ($self, $rssi) = @_;
  if ( $rssi ) {
    $self->estimote->redis->hset(estimote_beacons => $self->key => $rssi)
  } else {
    $self->estimote->redis->hget(estimote_beacons => $self->key)
  }
}

#has [qw/rtc major minor rssi noshow/];
#sub id { join '', map { $_[0]->$_ } qw/major minor/ }
#sub mm { map { $_[0]->$_ } qw/major minor/ }
#sub mmr { $_[0]->mm, $_[0]->rssi }

####################################################################
####################################################################
package RTC::AndroidEstimoteSDK;
use Mojo::Base 'Android::EstimoteSDK';
use Data::Dump;

sub details => sub { {} };
sub detail { shift->details->{shift()} }

sub refresh {
  my $self = shift;
  $self->scan;
  foreach my $key ( keys %{$self->beacons} ) {
    $self->details->{$key} ||= RTC::AndroidEstimoteSDK::Details->new(estimote => $self, beacon => $self->beacon($key));
  }
  foreach my $key ( keys %{$self->details} ) {
    delete $self->details->{$key} unless grep { $_ eq $key } keys %{$self->beacons};
  }
}

sub dump { Data::Dump::dump(shift->beacons) }

####################################################################
package RTC::AndroidEstimoteSDK::Details;
use Mojo::Base -base;

has 'estimote';
has 'beacon';

has 'details';

sub json {
  my $self = shift;
  $self->pull_details;
  return $self->details ? {beacon => $self->beacon, details => j($self->details)} : undef;
}

sub pull_details {
  my ($self, $me, $child) = @_;
  if ( $me ) {
    my ($rows, $_child, $fetching, $age, $parent, $json, $show, $pjson, $pshow) = $self->estimote->selectrow_array("select d0.uuid as cuuid,d1.fetching as fetching,d1.age as age,d1.parent as parent,d1.json as json,d1.show as show,d2.json as pjson,d2.show as pshow from details d1 left join details d2 on d1.parent=d2.uuid left join details d0 on d0.parent=d1.uuid where d1.uuid = ? limit 1", undef, $me);
    $self->estimote->do('insert into details (uuid) values (?)', undef, $me) unless $rows;

    #return if defined $show;
    #return $self->details($parent, $me) if $parent && defined $age && time() - $age < 86400 && not defined $pshow;
    #return $self->json($json) if defined $fetching && time() - $fetching < 7;

    return $self->noshow(1) if (defined $show && !$show) || (defined $pshow && !$pshow);
    return $self->json($json) if defined $fetching && time() - $fetching < 7;
    no warnings;
    warn sprintf "Checking details for %s -> %s | %s %s %s | %s %s %s\n", $self->rssi, $_child, $me, j($json||'{}')->{name}, $show, $parent, j($pjson||'{}')->{name}, $pshow;
    return $self->pull_details($parent, $me) if defined $parent && not defined $pshow;
    if ( (not defined $json) || ($age && time() - $age > 86400) ) {
      warn "Fetching...\n";
      $self->estimote->do("update details set fetching = strftime('%s', 'now') where uuid = ?", undef, $me);
      $self->estimote->ua->get(sprintf('%s/rtc/_design/lookup/_view/details?key="%s"', $self->estimote->couchdb, $me) => sub {
        my ($ua, $tx) = @_;
        my $json = $tx->res->json->{rows}->[0]->{value};
        $json->{child} = $child;
        $self->estimote->do("update details set fetching=null,age=strftime('%s', 'now'),parent=?,json=?,show=null where uuid = ?", undef, $json->{parent}, j($json), $me);
      });
    }
    return $self->json($json);
  } else {
    my ($rows, $fetching, $age, $parent) = $self->estimote->selectrow_array('select fetching,age,parent from beacons where major = ? and minor = ? limit 1', undef, $self->mm);
    $self->estimote->do('insert into beacons (major, minor) values (?, ?)', undef, $self->mm) unless $rows;
    return $self if defined $fetching && time() - $fetching < 7;
    return $self->details($parent, undef) if $parent && defined $age && time() - $age < 86400;
    $self->estimote->do("update beacons set fetching = strftime('%s', 'now') where major = ? and minor = ?", undef, $self->mm);
    $self->estimote->ua->get(sprintf('%s/rtc/_design/lookup/_view/beacon?key=[%s,%s]', $self->estimote->couchdb, $self->mm) => sub {
      my ($ua, $tx) = @_;
      my $json = $tx->res->json->{rows}->[0]->{value};
      $self->estimote->do("update beacons set fetching=null,age=strftime('%s', 'now'),parent=? where major = ? and minor = ?", undef, $json->{parent}, $self->mm);
    });
  }
  undef;
}

####################################################################
package RTC;
use Mojo::Base -base;
use Mojo::Redis2;
use Mojo::Log;
use Mojo::UserAgent;	
use Data::Dump;
use DBI;

has log => sub { Mojo::Log->new };
has ua => sub { Mojo::UserAgent->new };
has couchdb => 'http://db.xlxcd1.kit.cm:5984';
has db => sub { DBI->connect("dbi:SQLite:dbname=sql.db","","",{AutoCommit=>1}) };
has redis => sub { Mojo::Redis2->new };

has notifier => sub { RTC::AndroidNotifier->new };
has estimote => sub { RTC::AndroidEstimoteSDK->new(estimote => shift) };

sub create_tables {
  my $self = shift;
  $self->do("CREATE TABLE IF NOT EXISTS beacons (major integer, minor integer, fetching integer, age integer, parent text);");
  $self->do("CREATE TABLE IF NOT EXISTS details (uuid text, fetching integer, age integer, parent text, json text, show integer);");
}

sub response {
  my ($self, $uuid, $show) = @_;
  $self->do("update details set age=strftime('%s', 'now'),show=? where uuid = ?", undef, $show, $uuid);
}

sub reset {
  my $self = shift;
  $self->do("delete from details");
  $self->do("delete from beacons");
  $self->redis->del('beacons');
}

sub dump { Data::Dump::dump({major => $_[0]->major, minor => $_[0]->minor, rssi => $_[0]->rssi}) }
sub dumplog { $_[0]->rtc->log->debug($_[0]->dump); $_[0] }

sub do { shift->db->do(@_) }
sub selectrow_array {
  my $self = shift;
  my ($statement, $attr, @bind_values) = @_;
  my $sth = $self->db->prepare($statement, $attr||{}) or return undef;
  $sth->execute(@bind_values) or return undef;
  my @row = $sth->fetchrow_array;
  my $rows = $sth->rows;
  $sth->finish;
  $rows, @row;
}

sub refresh {
  my $self = shift;
  my @beacons = sort { $a->rssi <=> $b->rssi } grep { not defined $_->details->json->{show} } values %{shift->estimote->beacons} }
  my @strong = ();
  foreach ( 0..$#beacons ) {
    if ( $beacons[$_]->rssi <= $beacons[0]->rssi + 5 ) {
      push @strong, $beacons[$_];
    } else {
      last;
    }
  }
  Data::Dump::dump({strong => [map { $_->rssi } @strong]});
  my $notification = $self->notifier->notification;
  grep { $_->details->json->{_id} == $notification->{details}->{_id} } @strong;
}

####################################################################
package main;
use Mojolicious::Lite;

my $rtc = RTC->new;

get '/' => 'index';

post '/rssi/:beacon/:rssi' => {rssi => undef} => sub {
  my $c = shift;
  if ( ($c->param('beacon') =~ /^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})-(\d+)-(\d+)$/) ) {
    $rtc->estimote->beacon($2, $3)->rssi($c->param('rssi'));
    $c->render(text => '');
  } else {
    $c->render(text => '', status => 401);
  }
};

#post '/show/:uuid/:show' => [show => [(0,1,undef)]] => {show => undef} => sub {
post '/response/:uuid/:show' => {show => undef} => sub {
  my $c = shift;
  $rtc->estimote->response($c->param('uuid') => $c->param('show'));
  $rtc->notifier->clear;
  $c->render(text => $c->param('uuid') . ' => ' . ($c->param('show')?'Yes':'No'));
};

del '/reset' => sub {
  my $c = shift;
  $rtc->estimote->reset;
  $rtc->notifier->clear;
  $c->render(text => 'Reset');
};

websocket '/notification' => sub {
  my $c = shift;
  $c->on(frame => sub {
    my ($tx, $frame) = @_;
    Mojo::IOLoop->recurring(1 => sub {
      $tx->send({json => $rtc->notifier->notification});
    });
  });
};

$rtc->create_tables;
$rtc->estimote->dump;

Mojo::IOLoop->recurring(0.25 => sub {
  if ( $rtc->refresh ) {
    foreach ( $rtc->details ) {
      if ( $rtc->notifier->notify ) {
        warn "Posted!\n";
        last;
      } else {
        warn "Not Posted!\n";
      }
    }
  } else {
    warn "No change\n";
    return;
  }
});

app->start;

__DATA__

@@ notification.html.ep
% if ( $n->{json} ) {
  <a href="<%= $n->{json}->{url}->[0] %>"><%= $n->{json}->{name} %></a>
% }
